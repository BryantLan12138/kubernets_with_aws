# ACME App

To stand up the kubernetes cluster go into the `environment` directory and follow the directions in the make file
- make up   to spin up the infrastrucure of AWS
- make kube-up  to spind up the infrastcure of K8 cluster 

## Pass Level
### Part B
</br>
Helm chart are used to deploy an application, or one component of a large application on Kubernete. To generate 
The Helm chart for kubernete, use the command below
- helm create [usage]
Just in case, create the helm chart under the root directory. 
Change the directory into the generated helm chart, we need to clean up the stuff we don't need.
- cd app/a3-app
- rmdir charts
- rm -rf templates/* 
- cd templates 
A helm chart will always contain at least a Deployment and a Service, we need to create them now
- touch deployment.yml
- touch service.yml 

__Deployment.yml__
We will be describing what the application will look like when it is running on kubernetes. Firstly, we need to define 
which API version we are using and what kind of file this in first two rows.

Metadata is used for giving the deployment a name.

Next we will add the specification of the deployment. The _selector_ we use to identify the pods we manage, the _replica_ 
defines the number of pods that will be deployed. _Template_ which describes the pods themselves.

Then we need to define the specification for the _Containers_ we will run in the pod. In the case we will need to pull the 
docker image been generated by CI pipeline that pushed to AWS ECR service. Copy its URI into _values.yml_ file that used to
store the value of variables. To pass it into deployment.yml, we use { { .Values.image } } syntax to do that. 

Once we done that, we need to specify its enviornment variable of database to get the app connect with database. To do that,
we need to specify its _dbHostName_, _dbName_, _dbUser_ and _dbPassword_ to get it connected. Finally we need to specify the 
port allow traffic get in. To do that, you can either shift the default port under the file _www_ under the directory _src/bin_
to change it to port 80 to replace 3000. Or you can do is pass the port in to deployment.yml file. 

We keep the environment variables as default except the _dbHost_ that we going to use the RDS cluster we are building. To do that,
we need to change the directory into _infra_folder, pass in the terrafor output generated by environment folder, into the _Makefile_.
Then run -ENV=prod make init to spin up a new remote backend for production environment, then pass the generated value of VPC and 
subnets into _terraform.tfvars_ file. Finally by running -ENV=prod make up to spin up the RDS cluster into corresponding mode, store 
the output into _values.yml_ that used to be passed in _dbHostName_ vairable.

After everthing is done, we can deploy the appication to kubernetes cluster, by doing the command below:
- kubectl apply -f deployment.yml

Check whether the setting is correct by doing
- kubectl get pods

__service.yml__
