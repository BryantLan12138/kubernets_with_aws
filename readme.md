# ACME App

To stand up the kubernetes cluster go into the `environment` directory and follow the directions in the make file
- make up   to spin up the infrastrucure of AWS
- make kube-up  to spind up the infrastcure of K8 cluster 

## Pass Level
### Part B
</br>
Helm chart are used to deploy an application, or one component of a large application on Kubernete. To generate 
The Helm chart for kubernete, use the command below
- helm create acme
Just in case, create the helm chart under the root directory. 
Change the directory into the generated helm chart, we need to clean up the stuff we don't need.
- cd helm/acme
- rmdir charts
- rm -rf templates/* 
- cd templates 
A helm chart will always contain at least a Deployment and a Service, we need to create them now
- touch deployment.yml
- touch service.yml 

__Deployment.yml__
We will be describing what the application will look like when it is running on kubernetes. Firstly, we need to define 
which API version we are using and what kind of file this in first two rows.

Metadata is used for giving the deployment a name.

Next we will add the specification of the deployment. The _selector_ we use to identify the pods we manage, the _replica_ 
defines the number of pods that will be deployed. _Template_ which describes the pods themselves.

Then we need to define the specification for the _Containers_ we will run in the pod. In the case we will need to pull the 
docker image been generated by CI pipeline that pushed to AWS ECR service. Copy its URI into _values.yml_ file that used to
store the value of variables. To pass it into deployment.yml, we use { { .Values.image } } syntax to do that. 

Once we done that, we need to specify its enviornment variable of database to get the app connect with database. To do that,
we need to specify its _dbHostName_, _dbName_, _dbUser_ and _dbPassword_ to get it connected. Finally we need to specify the 
port allow traffic get in. To do that, you can either shift the default port under the file _www_ under the directory _src/bin_
to change it to port 80 to replace 3000 (that's because we are using port 80 for load balancer to receive ingress traffic later). 
Or you can do is pass the port 80 straight way in to deployment.yml file without changing the _www_ file. 

We keep the environment variables as default except the _dbHost_ that we going to use the RDS cluster we are building. To do that,
we need to change the directory into _infra_folder, pass in the terrafor output generated by environment folder, into the _Makefile_.
Then run -ENV=prod make init to spin up a new remote backend for production environment, then pass the generated value of VPC and 
subnets into _terraform.tfvars_ file. Finally by running -ENV=prod make up to spin up the RDS cluster into corresponding mode, store 
the output into _values.yml_ that used to be passed in _dbHostName_ vairable.

After everthing is done, we can deploy the appication to kubernetes cluster, by doing the command below:
- kubectl apply -f deployment.yml

Check whether the setting is correct by doing
- kubectl get pods
The status of each pods should be running once it finished creation now.

__service.yml__
The application now is deployed to kubernetes cluster and be accessible internally, but for make it publicly we need to define a way 
for external user to access it. We do that by defining a service and setting up an ingress through a load balancer.
We specify the version as same as deployment, but change the kind to _Service_ instead 
</br>
The port section matches the port from deployment, and it will open the port and map from port to targetPort, by using TCP protocal.
The load balancer will be created by kubernetes and configured for us to be our ingress automatically. 

Now that the manifest is complete, we will apply it on kubernetes cluster by
-kubectl apply -f service.yml

Once you done that, get the elb IP by use
-kubectl get services 
Pick the one with our project name, wait for few minutes for elb to configure itsleves properly.

Now you can see the app with db setup from the browser.

Finally change directory to the folder _helm_ and package the helm chart with command 
- helm package acme 
To be installed later on.


Now you should be able to pass CI as well, before that you need to do 2 things.
1. change the kops_state_bucket_name to yours on _config.yml_ line 24.
2. uncomment the command commented before for package helm.
    
### Part C
Deploy